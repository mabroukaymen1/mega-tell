"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = void 0;
const core_1 = require("./core");
const cursor_1 = require("./cursor");
const types_1 = require("./types");
const util_1 = require("./util");
/**
 * An object used to filter input documents
 *
 * @param {Object} condition The condition for constructing predicates
 * @param {Options} options Options for use by operators
 * @constructor
 */
class Query {
    constructor(condition, options) {
        this.condition = condition;
        this.options = (0, core_1.initOptions)(options);
        this.compiled = [];
        this.compile();
    }
    compile() {
        (0, util_1.assert)((0, util_1.isObject)(this.condition), `query criteria must be an object: ${JSON.stringify(this.condition)}`);
        const whereOperator = {};
        for (const [field, expr] of Object.entries(this.condition)) {
            if ("$where" === field) {
                Object.assign(whereOperator, { field: field, expr: expr });
            }
            else if ((0, util_1.inArray)(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
                this.processOperator(field, field, expr);
            }
            else {
                // normalize expression
                (0, util_1.assert)(!(0, util_1.isOperator)(field), `unknown top level operator: ${field}`);
                for (const [operator, val] of Object.entries((0, util_1.normalize)(expr))) {
                    this.processOperator(field, operator, val);
                }
            }
            if (whereOperator.field) {
                this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
            }
        }
    }
    processOperator(field, operator, value) {
        const call = (0, core_1.getOperator)(core_1.OperatorType.QUERY, operator, this.options);
        if (!call) {
            throw new types_1.MingoError(`unknown query operator ${operator}`);
        }
        const fn = call(field, value, this.options);
        this.compiled.push(fn);
    }
    /**
     * Checks if the object passes the query criteria. Returns true if so, false otherwise.
     *
     * @param obj The object to test
     * @returns {boolean} True or false
     */
    test(obj) {
        for (let i = 0, len = this.compiled.length; i < len; i++) {
            if (!this.compiled[i](obj)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a cursor to select matching documents from the input source.
     *
     * @param source A source providing a sequence of documents
     * @param projection An optional projection criteria
     * @returns {Cursor} A Cursor for iterating over the results
     */
    find(collection, projection) {
        return new cursor_1.Cursor(collection, ((x) => this.test(x)), projection || {}, this.options);
    }
    /**
     * Remove matched documents from the collection returning the remainder
     *
     * @param collection An array of documents
     * @returns {Array} A new array with matching elements removed
     */
    remove(collection) {
        return collection.reduce((acc, obj) => {
            if (!this.test(obj))
                acc.push(obj);
            return acc;
        }, []);
    }
}
exports.Query = Query;
